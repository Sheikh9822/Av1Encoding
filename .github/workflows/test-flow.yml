name: AV1 Mini Encode Test

on:
  workflow_dispatch:
    inputs:
      source_url:
        description: "Direct video URL"
        required: true
      crf:
        description: "CRF value (31-45 recommended)"
        default: "40"
      preset:
        description: "SVT-AV1 preset (4=slower/better, 6=faster/worse)"
        default: "5"
      film_grain:
        description: "Film grain synthesis (0=off, 4=light, 8=heavy)"
        default: "4"
      sample_start:
        description: "Start time in seconds (0 = full video)"
        default: "0"
      sample_duration:
        description: "Duration seconds (0 = full video)"
        default: "120"

jobs:
  encode:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Install Dependencies
      run: |
        sudo apt update
        # Added fonts-dejavu so ImageMagick text annotation works
        sudo apt install -y ffmpeg mkvtoolnix wget mediainfo xz-utils imagemagick fonts-dejavu

    - name: Download Source (with Headers)
      run: |
        echo "Downloading source..."
        # Added User-Agent and Referer to bypass HTTP 403 Forbidden
        wget \
          --header="Referer: https://kwik.cx/" \
          --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" \
          -O input.mkv "${{ github.event.inputs.source_url }}"
        
        # Verify download validity
        if [ ! -s input.mkv ]; then
          echo "Error: File is empty or failed to download."
          exit 1
        fi
        ls -lh input.mkv

    - name: Media Info
      run: mediainfo input.mkv

    - name: Encode & Reference
      run: |
        CRF=${{ github.event.inputs.crf }}
        PRESET=${{ github.event.inputs.preset }}
        FILM_GRAIN=${{ github.event.inputs.film_grain }}
        START=${{ github.event.inputs.sample_start }}
        DURATION=${{ github.event.inputs.sample_duration }}

        CUT_OPTS=""
        if [ "$DURATION" != "0" ]; then
          CUT_OPTS="-ss $START -t $DURATION"
          echo "Encoding SAMPLE CLIP (${DURATION}s)"
        else
          echo "Encoding FULL VIDEO"
        fi

        # 1. Extract Reference (Running sequentially to save RAM/CPU for the encode)
        echo "--- Extracting Reference ---"
        ffmpeg -hide_banner -y $CUT_OPTS -i input.mkv \
          -map 0:v:0 -c:v copy reference.mkv

        # 2. Run AV1 Encode
        # Using -ac 2 with libopus automatically handles standard downmixing robustly
        echo "--- Starting AV1 Encode ---"
        
        ffmpeg -hide_banner -y $CUT_OPTS -i input.mkv \
          -map 0:v:0 \
          -map 0:a? \
          -map 0:s? \
          -map_metadata 0 \
          -vf "hqdn3d=1.5:1.5:6:6,gradfun=1.2" \
          -c:v libsvtav1 \
          -pix_fmt yuv420p10le \
          -preset $PRESET \
          -crf $CRF \
          -svtav1-params "tune=0:aq-mode=2:enable-overlays=1:scd=1:lookahead=120:film-grain=$FILM_GRAIN:tile-columns=2:tile-rows=1:keyint=240" \
          -c:a libopus -b:a 128k -ac 2 \
          -c:s copy \
          output.mkv

    - name: Show Output Info
      run: |
        mediainfo output.mkv
        ls -lh output.mkv

    - name: Screenshot Comparison
      run: |
        mkdir -p screenshots
        
        # Get actual duration of output
        DURATION_MS=$(ffprobe -v quiet -show_entries format=duration \
          -of csv=p=0 output.mkv | python3 -c "import sys; print(int(float(sys.stdin.read().strip()) * 1000))")
        
        echo "Clip duration: ${DURATION_MS}ms"

        # Generate timestamps
        python3 -c "
        import random
        duration_ms = $DURATION_MS
        margin_ms = 1000
        available = duration_ms - margin_ms * 2
        
        if available < 1:
            count = min(5, duration_ms // 1000)
            timestamps_ms = sorted(random.sample(range(0, duration_ms), count))
        else:
            count = 10
            timestamps_ms = sorted(random.sample(range(margin_ms, duration_ms - margin_ms), count))
            
        print(f'Sampling {count} frames', flush=True)
        for t in timestamps_ms:
            h = t // 3600000
            m = (t % 3600000) // 60000
            s = (t % 60000) // 1000
            ms = t % 1000
            print(f'{h:02d}:{m:02d}:{s:02d}.{ms:03d}')
        " > timestamps_raw.txt

        tail -n +2 timestamps_raw.txt > timestamps.txt
        
        i=1
        while read -r T; do
          echo "Generating Compare Frame $i at ${T}..."
          
          # Extract Source Frame
          ffmpeg -nostdin -ss $T -i reference.mkv \
            -frames:v 1 -vf "scale=960:-1" -q:v 2 "screenshots/src_${i}.png" -y 2>/dev/null
          
          # Extract Encoded Frame
          ffmpeg -nostdin -ss $T -i output.mkv \
            -frames:v 1 -vf "scale=960:-1" -q:v 2 "screenshots/enc_${i}.png" -y 2>/dev/null

          # Combine
          convert \
            \( "screenshots/src_${i}.png" \
               -gravity North -background '#00000099' \
               -splice 0x30 -fill white -font DejaVu-Sans -pointsize 22 \
               -annotate +0+6 "SOURCE  |  t=${T}" \) \
            \( "screenshots/enc_${i}.png" \
               -gravity North -background '#00000099' \
               -splice 0x30 -fill white -font DejaVu-Sans -pointsize 22 \
               -annotate +0+6 "AV1  |  CRF=${{ github.event.inputs.crf }}  |  Grain=${{ github.event.inputs.film_grain }}" \) \
            +append \
            "screenshots/compare_${i}_${T//:/-}.jpg"
            
          i=$((i + 1))
        done < timestamps.txt

        rm -f reference.mkv screenshots/*.png

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: "AV1-CRF${{ github.event.inputs.crf }}-P${{ github.event.inputs.preset }}-G${{ github.event.inputs.film_grain }}"
        path: |
          output.mkv
          screenshots/compare_*.jpg
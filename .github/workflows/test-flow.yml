
name: AV1 Mini Encode Test

on:
  workflow_dispatch:
    inputs:
      source_url:
        description: "Direct video URL"
        required: true

      crf:
        description: "CRF value (31-45 recommended)"
        default: "40"

      preset:
        description: "SVT-AV1 preset (4=slower/better, 6=faster/worse)"
        default: "4"

      film_grain:
        description: "Film grain synthesis (0=off, 4=light, 8=heavy)"
        default: "4"

      sample_start:
        description: "Start time in seconds (0 = full video)"
        default: "0"

      sample_duration:
        description: "Duration seconds (0 = full video)"
        default: "120"

jobs:
  encode:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Install Dependencies
      run: |
        sudo apt update
        sudo apt install -y ffmpeg mkvtoolnix wget mediainfo xz-utils imagemagick

    - name: Show System Info
      run: |
        lscpu
        free -h
        df -h

    - name: Download Source
      run: |
        echo "Downloading source..."
        wget -O input.mkv "${{ github.event.inputs.source_url }}"

    - name: Media Info
      run: mediainfo input.mkv

    - name: Encode + Extract Reference (Parallel)
      run: |
        CRF=${{ github.event.inputs.crf }}
        PRESET=${{ github.event.inputs.preset }}
        FILM_GRAIN=${{ github.event.inputs.film_grain }}
        START=${{ github.event.inputs.sample_start }}
        DURATION=${{ github.event.inputs.sample_duration }}

        echo "CRF: $CRF"
        echo "Preset: $PRESET"
        echo "Film grain: $FILM_GRAIN"
        echo "Start: $START"
        echo "Duration: $DURATION"

        CUT_IN=""
        CUT_OUT=""
        if [ "$DURATION" != "0" ]; then
          CUT_IN="-ss $START"
          CUT_OUT="-t $DURATION"
          echo "Encoding SAMPLE CLIP"
        else
          echo "Encoding FULL VIDEO"
        fi

        # Build metadata flags as array to safely handle spaces in titles
        METADATA_FLAGS=()
        AUDIO_IDX=0
        SUB_IDX=0
        VIDEO_DONE=0

        # Also detect per-stream channel count for smart downmix
        CHANNEL_COUNTS=()
        while IFS='|' read -r TYPE LANG TITLE CHANNELS; do
          case "$TYPE" in
            video)
              if [ "$VIDEO_DONE" = "0" ]; then
                SPECIFIER="v:0"
                VIDEO_DONE=1
              else
                continue
              fi
              ;;
            audio)
              SPECIFIER="a:$AUDIO_IDX"
              CHANNEL_COUNTS+=("$CHANNELS")
              # Normalize audio title to reflect stereo downmix
              TITLE=$(echo "$TITLE" | sed \
                -e 's/5\.1[^a-zA-Z]*/Stereo/Ig' \
                -e 's/7\.1[^a-zA-Z]*/Stereo/Ig' \
                -e 's/[0-9]\.[0-9]ch/Stereo/Ig' \
                -e 's/: Stereo: Stereo/: Stereo/Ig')
              AUDIO_IDX=$((AUDIO_IDX + 1))
              ;;
            subtitle)
              SPECIFIER="s:$SUB_IDX"
              SUB_IDX=$((SUB_IDX + 1))
              ;;
            *) continue ;;
          esac
          [ -n "$LANG" ]  && METADATA_FLAGS+=(-metadata:s:$SPECIFIER "language=$LANG")
          [ -n "$TITLE" ] && METADATA_FLAGS+=(-metadata:s:$SPECIFIER "title=$TITLE")
        done < <(ffprobe -v quiet \
          -show_entries stream=codec_type:stream=channels:stream_tags=language,title \
          -of csv=p=0 input.mkv 2>/dev/null | \
          awk -F',' '{print $1"|"$2"|"$3"|"$4}')

        echo "Metadata flags: ${METADATA_FLAGS[@]}"
        echo "Channel counts per audio track: ${CHANNEL_COUNTS[@]}"

        # Build per-track audio filter based on channel count
        # Multichannel (>2) gets 5.1->stereo pan downmix, stereo stays as-is
        AUDIO_FILTER_COMPLEX=""
        AUDIO_MAP=""
        for idx in "${!CHANNEL_COUNTS[@]}"; do
          CH="${CHANNEL_COUNTS[$idx]}"
          if [ "$CH" -gt 2 ] 2>/dev/null; then
            AUDIO_FILTER_COMPLEX+="[0:a:$idx]aformat=channel_layouts='5.1|stereo|mono',pan=stereo|FL=FC+0.30*FL+0.30*BL+0.21*LFE|FR=FC+0.30*FR+0.30*BR+0.21*LFE[a$idx];"
            AUDIO_MAP+="-map [a$idx] "
          else
            AUDIO_MAP+="-map 0:a:$idx "
          fi
        done
        # Trim trailing semicolon
        AUDIO_FILTER_COMPLEX="${AUDIO_FILTER_COMPLEX%;}"

        echo "Audio filter complex: $AUDIO_FILTER_COMPLEX"
        echo "Audio map: $AUDIO_MAP"

        # Start reference extraction in background
        echo "Starting reference extraction in background..."
        ffmpeg -nostdin $CUT_IN -i input.mkv $CUT_OUT \
          -map 0:v:0 -c:v copy reference.mkv &
        REF_PID=$!

        # Start encode in background
        echo "Starting AV1 encode in background..."
        if [ -n "$AUDIO_FILTER_COMPLEX" ]; then
          FILTER_ARGS=(-filter_complex "$AUDIO_FILTER_COMPLEX")
        else
          FILTER_ARGS=()
        fi

        ffmpeg -nostdin $CUT_IN -i input.mkv $CUT_OUT \
        -map 0:v:0 \
        $AUDIO_MAP \
        -map 0:s? \
        -map_metadata 0 \
        -map_metadata:s -1 \
        "${METADATA_FLAGS[@]}" \
        "${FILTER_ARGS[@]}" \
        -vf "hqdn3d=1.5:1.5:6:6,gradfun=1.2" \
        -c:v libsvtav1 \
        -pix_fmt yuv420p10le \
        -preset $PRESET \
        -crf $CRF \
        -svtav1-params "tune=0:aq-mode=2:enable-overlays=1:scd=1:lookahead=120:film-grain=$FILM_GRAIN:tile-columns=2:tile-rows=1:keyint=240" \
        -c:a libopus -b:a 96k -ac 2 \
        -c:s copy \
        output.mkv &
        ENCODE_PID=$!

        echo "Waiting for reference extraction..."
        wait $REF_PID || { echo "Reference extraction failed"; exit 1; }
        echo "Reference done."

        echo "Waiting for encode..."
        wait $ENCODE_PID || { echo "Encode failed"; exit 1; }
        echo "Encode done."

        df -h

    - name: Show Output Info
      run: |
        mediainfo output.mkv
        ls -lh

    - name: Screenshot Comparison (10 random frames)
      run: |
        mkdir -p screenshots

        DURATION_MS=$(ffprobe -v quiet -show_entries format=duration \
          -of csv=p=0 output.mkv | python3 -c "import sys; print(int(float(sys.stdin.read().strip()) * 1000))")
        echo "Clip duration: ${DURATION_MS}ms"

        python3 -c "
        import random
        duration_ms = $DURATION_MS
        margin_ms = 2000
        available = duration_ms - margin_ms * 2
        if available < 1:
            count = min(10, duration_ms)
            timestamps_ms = sorted(random.sample(range(0, duration_ms), count))
        else:
            count = min(10, available)
            timestamps_ms = sorted(random.sample(range(margin_ms, duration_ms - margin_ms), count))
        print(f'Sampling {count} frames', flush=True)
        for t in timestamps_ms:
            h = t // 3600000
            m = (t % 3600000) // 60000
            s = (t % 60000) // 1000
            ms = t % 1000
            print(f'{h:02d}:{m:02d}:{s:02d}.{ms:03d}')
        " > timestamps_raw.txt

        head -1 timestamps_raw.txt
        tail -n +2 timestamps_raw.txt > timestamps.txt
        cat timestamps.txt

        i=1
        while read -r T; do
          echo "Frame $i at ${T}..."

          ffmpeg -nostdin -i reference.mkv \
            -ss $T -vf "scale=960:-1" -frames:v 1 -q:v 2 \
            "screenshots/src_${i}.png" -y 2>/dev/null

          ffmpeg -nostdin -i output.mkv \
            -ss $T -vf "scale=960:-1" -frames:v 1 -q:v 2 \
            "screenshots/enc_${i}.png" -y 2>/dev/null

          convert \
            \( "screenshots/src_${i}.png" \
               -gravity North -background '#00000099' \
               -splice 0x30 -fill white -font DejaVu-Sans -pointsize 22 \
               -annotate +0+6 "SOURCE  |  t=${T}" \) \
            \( "screenshots/enc_${i}.png" \
               -gravity North -background '#00000099' \
               -splice 0x30 -fill white -font DejaVu-Sans -pointsize 22 \
               -annotate +0+6 "ENCODED  |  CRF=${{ github.event.inputs.crf }}  |  grain=${{ github.event.inputs.film_grain }}  |  t=${T}" \) \
            +append \
            "screenshots/compare_${i}_${T//:/-}.jpg"

          echo "  -> compare_${i}_${T//:/-}.jpg done"
          i=$((i + 1))
        done < timestamps.txt

        ls -lh screenshots/compare_*.jpg

        # Free up disk space
        echo "Cleaning up reference file..."
        rm -f reference.mkv
        df -h

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: "crf${{ github.event.inputs.crf }}-preset${{ github.event.inputs.preset }}-grain${{ github.event.inputs.film_grain }}-run${{ github.run_number }}"
        path: |
          output.mkv
          screenshots/compare_*.jpg
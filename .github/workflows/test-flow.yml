name: AV1 Ultimate (Full Metadata Fix)

on:
  workflow_dispatch:
    inputs:
      source_url:
        description: "Direct video URL"
        required: true
      crf:
        description: "CRF (Rec: 50-60)"
        default: "55"
      max_bitrate:
        description: "Target Bitrate (e.g. 350k, 600k)"
        default: "350k"
      preset:
        description: "Preset (6=Good Speed/Quality)"
        default: "6"
      film_grain:
        description: "Film Grain (0-50). 0 = Off."
        default: "0"
      sample_duration:
        description: "Duration (0=Full)"
        default: "60"

jobs:
  encode:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
    - uses: actions/checkout@v4

    - name: Install Dependencies
      run: |
        sudo apt update -y
        sudo apt install -y ffmpeg mkvtoolnix wget mediainfo imagemagick fonts-dejavu

    - name: Download Source
      run: |
        wget --header="Referer: https://kwik.cx/" \
             --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" \
             -O input.mkv "${{ github.event.inputs.source_url }}"

    - name: Configure (Metadata & Auto-Buffer)
      id: prep
      run: |
        # 1. BUFFER CALCULATION (9.5 Seconds)
        BITRATE_VAL=$(echo "${{ github.event.inputs.max_bitrate }}" | tr -dc '0-9')
        BUF_VAL=$(( (BITRATE_VAL * 19) / 2 ))
        echo "BUFSIZE=${BUF_VAL}k" >> $GITHUB_ENV

        # 2. SVT-AV1 DYNAMIC PARAMS
        PARAMS="aq-mode=2:enable-overlays=1:scd=1:lookahead=120:keyint=240"
        GRAIN=${{ github.event.inputs.film_grain }}
        if [ "$GRAIN" -gt "0" ]; then PARAMS="$PARAMS:film-grain=$GRAIN"; fi
        echo "SVT_PARAMS=$PARAMS" >> $GITHUB_ENV

        # 3. GLOBAL & STREAM METADATA LOGIC
        METADATA_FLAGS=()
        
        # Get Global Title
        GLOBAL_TITLE=$(ffprobe -v quiet -show_entries format_tags=title -of default=noprint_wrappers=1:nokey=1 input.mkv | head -n 1)
        if [ -z "$GLOBAL_TITLE" ]; then GLOBAL_TITLE="AV1 Mini Encode"; fi
        METADATA_FLAGS+=("-metadata" "title=$GLOBAL_TITLE")
        echo "Global Title Found: $GLOBAL_TITLE"

        AUDIO_MAP=""
        AUDIO_FILTER=""
        A_IDX=0
        S_IDX=0
        
        # Parse all streams (Type, Channels, Language, Title)
        ffprobe -v quiet -show_entries stream=codec_type,channels:stream_tags=language,title \
          -of csv=p=0 input.mkv > streams.csv

        while IFS=',' read -r TYPE CHANNELS LANG TITLE; do
          case "$TYPE" in
            audio)
              SPEC="a:$A_IDX"
              # Handle Downmix
              if [ "$CHANNELS" -gt 2 ]; then
                AUDIO_FILTER+="[0:a:$A_IDX]aformat=channel_layouts='5.1|stereo|mono',pan=stereo|FL=FC+0.30*FL+0.30*BL+0.21*LFE|FR=FC+0.30*FR+0.30*BR+0.21*LFE[a$A_IDX];"
                AUDIO_MAP+="-map [a$A_IDX] "
              else
                AUDIO_MAP+="-map 0:a:$A_IDX "
              fi
              
              # Rename Metadata: Fixes "Stereoch" bug
              # This removes "5.1", "7.1", "ch", and "channels" specifically
              CLEAN_TITLE=$(echo "$TITLE" | sed -E 's/(5\.1|7\.1|6ch|8ch|ch|channels)//Ig' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')
              FINAL_AUDIO_TITLE="${CLEAN_TITLE}: Stereo"
              
              [ -n "$LANG" ] && METADATA_FLAGS+=("-metadata:s:$SPEC" "language=$LANG")
              METADATA_FLAGS+=("-metadata:s:$SPEC" "title=$FINAL_AUDIO_TITLE")
              A_IDX=$((A_IDX + 1))
              ;;
            
            subtitle)
              SPEC="s:$S_IDX"
              # Capture Subtitle Lang and Title exactly as in source
              [ -n "$LANG" ] && METADATA_FLAGS+=("-metadata:s:$SPEC" "language=$LANG")
              [ -n "$TITLE" ] && METADATA_FLAGS+=("-metadata:s:$SPEC" "title=$TITLE")
              S_IDX=$((S_IDX + 1))
              ;;
          esac
        done < streams.csv
        
        [ -n "$AUDIO_FILTER" ] && AUDIO_FILTER="${AUDIO_FILTER%;}"
        echo "AUDIO_MAP=$AUDIO_MAP" >> $GITHUB_ENV
        echo "AUDIO_FILTER=$AUDIO_FILTER" >> $GITHUB_ENV
        
        # Save array to a binary file to preserve spaces in titles
        printf "%s\0" "${METADATA_FLAGS[@]}" > metadata_flags.bin

    - name: Extract Reference
      run: |
        DUR="${{ github.event.inputs.sample_duration }}"
        [ "$DUR" != "0" ] && CUT="-t $DUR" || CUT=""
        ffmpeg -hide_banner -y -probesize 100M -analyzeduration 100M -i input.mkv $CUT -map 0:v:0 -c:v copy reference.mkv

    - name: Run AV1 Encode
      run: |
        DUR="${{ github.event.inputs.sample_duration }}"
        [ "$DUR" != "0" ] && CUT="-t $DUR" || CUT=""
        
        # Load Metadata Flags safely
        METADATA_ARGS=()
        while IFS= read -r -d '' flag; do METADATA_ARGS+=("$flag"); done < metadata_flags.bin
        
        F_ARGS=()
        if [ -n "$AUDIO_FILTER" ]; then F_ARGS=(-filter_complex "$AUDIO_FILTER"); fi
        
        ffmpeg -hide_banner -y -probesize 100M -analyzeduration 100M -i input.mkv $CUT \
        -map 0:v:0 \
        $AUDIO_MAP \
        -map 0:s? \
        -map_metadata 0 \
        -map_metadata:s -1 \
        "${METADATA_ARGS[@]}" \
        "${F_ARGS[@]}" \
        -vf "hqdn3d=1.5:1.5:6:6,gradfun=1.2" \
        -c:v libsvtav1 \
        -pix_fmt yuv420p10le \
        -preset ${{ github.event.inputs.preset }} \
        -crf ${{ github.event.inputs.crf }} \
        -b:v ${{ github.event.inputs.max_bitrate }} \
        -maxrate ${{ github.event.inputs.max_bitrate }} \
        -bufsize $BUFSIZE \
        -svtav1-params "$SVT_PARAMS" \
        -c:a libopus -b:a 96k -ac 2 \
        -c:s copy \
        output.mkv

    - name: Show Results
      run: mediainfo output.mkv

    - name: Generate Comparison
      run: |
        mkdir -p screenshots
        DUR_MS=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 output.mkv | python3 -c "import sys; print(int(float(sys.stdin.read().strip()) * 1000))")
        python3 -c "
        import random
        duration = $DUR_MS
        timestamps = sorted(random.sample(range(2000, duration-2000), 5))
        for t in timestamps:
            print(f'{t//3600000:02d}:{(t%3600000)//60000:02d}:{(t%60000)//1000:02d}.{t%1000:03d}')
        " > timestamps.txt

        i=1
        while read -r T; do
          ffmpeg -nostdin -ss $T -i reference.mkv -frames:v 1 -vf "scale=960:-1" -q:v 2 "screenshots/src_$i.png" -y 2>/dev/null
          ffmpeg -nostdin -ss $T -i output.mkv    -frames:v 1 -vf "scale=960:-1" -q:v 2 "screenshots/enc_$i.png" -y 2>/dev/null
          convert \( "screenshots/src_$i.png" -gravity North -background '#00000099' -splice 0x30 -fill white -font DejaVu-Sans -pointsize 20 -annotate +0+6 "SOURCE | $T" \) \
                  \( "screenshots/enc_$i.png" -gravity North -background '#00000099' -splice 0x30 -fill white -font DejaVu-Sans -pointsize 20 -annotate +0+6 "AV1 | Bitrate:${{ github.event.inputs.max_bitrate }} | CRF:${{ github.event.inputs.crf }}" \) \
                  +append "screenshots/compare_$i.jpg"
          i=$((i+1))
        done < timestamps.txt

    - name: Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: "AV1-Pro-Metadata-${{ github.event.inputs.max_bitrate }}"
        path: |
          output.mkv
          screenshots/*.jpg